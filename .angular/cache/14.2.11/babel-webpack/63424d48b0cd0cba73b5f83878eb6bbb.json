{"ast":null,"code":"/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // allocate result\n\n  var parent = []; // (n)\n  // allocate workspace\n\n  var w = []; // (n + (ata ? m : 0))\n\n  var ancestor = 0; // first n entries in w\n\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n\n  return parent;\n}","map":{"version":3,"names":["csEtree","a","ata","aindex","_index","aptr","_ptr","asize","_size","m","n","parent","w","ancestor","prev","i","inext","k","p0","p1","p","r"],"sources":["C:/Users/lenovo/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js"],"sourcesContent":["/**\n * Computes the elimination tree of Matrix A (using triu(A)) or the\n * elimination tree of A'A without forming A'A.\n *\n * @param {Matrix}  a               The A Matrix\n * @param {boolean} ata             A value of true the function computes the etree of A'A\n *\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  }\n  // a arrays\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size;\n  // rows & columns\n  var m = asize[0];\n  var n = asize[1];\n\n  // allocate result\n  var parent = []; // (n)\n\n  // allocate workspace\n  var w = []; // (n + (ata ? m : 0))\n  var ancestor = 0; // first n entries in w\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext;\n\n  // check we are calculating A'A\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  }\n  // loop columns\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1;\n    // nor does k have an ancestor\n    w[ancestor + k] = -1;\n    // values in column k\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p];\n      // node\n      i = ata ? w[prev + r] : r;\n      // traverse from i to k\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i];\n        // path compression\n        w[ancestor + i] = k;\n        // check no anc., parent is k\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n  return parent;\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,OAAT,CAAiBC,CAAjB,EAAoBC,GAApB,EAAyB;EAC9B;EACA,IAAI,CAACD,CAAL,EAAQ;IACN,OAAO,IAAP;EACD,CAJ6B,CAK9B;;;EACA,IAAIE,MAAM,GAAGF,CAAC,CAACG,MAAf;EACA,IAAIC,IAAI,GAAGJ,CAAC,CAACK,IAAb;EACA,IAAIC,KAAK,GAAGN,CAAC,CAACO,KAAd,CAR8B,CAS9B;;EACA,IAAIC,CAAC,GAAGF,KAAK,CAAC,CAAD,CAAb;EACA,IAAIG,CAAC,GAAGH,KAAK,CAAC,CAAD,CAAb,CAX8B,CAa9B;;EACA,IAAII,MAAM,GAAG,EAAb,CAd8B,CAcb;EAEjB;;EACA,IAAIC,CAAC,GAAG,EAAR,CAjB8B,CAiBlB;;EACZ,IAAIC,QAAQ,GAAG,CAAf,CAlB8B,CAkBZ;;EAClB,IAAIC,IAAI,GAAGJ,CAAX,CAnB8B,CAmBhB;;EAEd,IAAIK,CAAJ,EAAOC,KAAP,CArB8B,CAuB9B;;EACA,IAAId,GAAJ,EAAS;IACP;IACA,KAAKa,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGN,CAAhB,EAAmBM,CAAC,EAApB,EAAwB;MACtBH,CAAC,CAACE,IAAI,GAAGC,CAAR,CAAD,GAAc,CAAC,CAAf;IACD;EACF,CA7B6B,CA8B9B;;;EACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;IAC1B;IACAN,MAAM,CAACM,CAAD,CAAN,GAAY,CAAC,CAAb,CAF0B,CAG1B;;IACAL,CAAC,CAACC,QAAQ,GAAGI,CAAZ,CAAD,GAAkB,CAAC,CAAnB,CAJ0B,CAK1B;;IACA,KAAK,IAAIC,EAAE,GAAGb,IAAI,CAACY,CAAD,CAAb,EAAkBE,EAAE,GAAGd,IAAI,CAACY,CAAC,GAAG,CAAL,CAA3B,EAAoCG,CAAC,GAAGF,EAA7C,EAAiDE,CAAC,GAAGD,EAArD,EAAyDC,CAAC,EAA1D,EAA8D;MAC5D;MACA,IAAIC,CAAC,GAAGlB,MAAM,CAACiB,CAAD,CAAd,CAF4D,CAG5D;;MACAL,CAAC,GAAGb,GAAG,GAAGU,CAAC,CAACE,IAAI,GAAGO,CAAR,CAAJ,GAAiBA,CAAxB,CAJ4D,CAK5D;;MACA,OAAON,CAAC,KAAK,CAAC,CAAP,IAAYA,CAAC,GAAGE,CAAvB,EAA0BF,CAAC,GAAGC,KAA9B,EAAqC;QACnC;QACAA,KAAK,GAAGJ,CAAC,CAACC,QAAQ,GAAGE,CAAZ,CAAT,CAFmC,CAGnC;;QACAH,CAAC,CAACC,QAAQ,GAAGE,CAAZ,CAAD,GAAkBE,CAAlB,CAJmC,CAKnC;;QACA,IAAID,KAAK,KAAK,CAAC,CAAf,EAAkB;UAChBL,MAAM,CAACI,CAAD,CAAN,GAAYE,CAAZ;QACD;MACF;;MACD,IAAIf,GAAJ,EAAS;QACPU,CAAC,CAACE,IAAI,GAAGO,CAAR,CAAD,GAAcJ,CAAd;MACD;IACF;EACF;;EACD,OAAON,MAAP;AACD"},"metadata":{},"sourceType":"module"}