{"ast":null,"code":"import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'fft';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i', 'dotDivide', 'conj', 'pow', 'ceil', 'log2'];\nexport var createFft = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    divideScalar,\n    exp,\n    tau,\n    i: I,\n    dotDivide,\n    conj,\n    pow,\n    ceil,\n    log2\n  } = _ref;\n  /**\n   * Calculate N-dimensional fourier transform\n   *\n   * Syntax:\n   *\n   *     math.fft(arr)\n   *\n   * Examples:\n   *\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\n   *\n   *\n   * See Also:\n   *\n   *      ifft\n   *\n   * @param {Array | Matrix} arr    An array or matrix\n   * @return {Array | Matrix}       N-dimensional fourier transformation of the array\n   */\n\n  return typed(name, {\n    Array: _ndFft,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_ndFft(matrix.toArray()));\n    }\n  });\n  /**\n   * Perform an N-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n\n  function _ndFft(arr) {\n    var size = arraySize(arr);\n    if (size.length === 1) return _fft(arr, size[0]); // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\n\n    return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);\n  }\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @param {number} dim     dimension of the array to perform on\n   * @return {Array}         resulting array\n   */\n\n\n  function _1dFft(arr, dim) {\n    var size = arraySize(arr);\n    if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));\n    if (size.length === 1) return _fft(arr);\n\n    function _transpose(arr) {\n      // Swap first 2 dimensions\n      var size = arraySize(arr);\n      return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));\n    }\n\n    return _transpose(_1dFft(_transpose(arr), 1));\n  }\n  /**\n   * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n\n\n  function _czt(arr) {\n    var n = arr.length;\n    var w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau)), n));\n    var chirp = [];\n\n    for (var i = 1 - n; i < n; i++) {\n      chirp.push(pow(w, divideScalar(pow(i, 2), 2)));\n    }\n\n    var N2 = pow(2, ceil(log2(n + n - 1)));\n    var xp = [...new Array(n).fill(0).map((_, i) => multiplyScalar(arr[i], chirp[n - 1 + i])), ...new Array(N2 - n).fill(0)];\n    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i) => divideScalar(1, chirp[i])), ...new Array(N2 - (n + n - 1)).fill(0)];\n\n    var fftXp = _fft(xp);\n\n    var fftIchirp = _fft(ichirp);\n\n    var fftProduct = new Array(N2).fill(0).map((_, i) => multiplyScalar(fftXp[i], fftIchirp[i]));\n    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);\n    var ret = [];\n\n    for (var _i = n - 1; _i < n + n - 1; _i++) {\n      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));\n    }\n\n    return ret;\n  }\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n\n\n  function _fft(arr) {\n    var len = arr.length;\n    if (len === 1) return [arr[0]];\n\n    if (len % 2 === 0) {\n      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];\n\n      for (var k = 0; k < len / 2; k++) {\n        var p = ret[k];\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\n        ret[k] = addScalar(p, q);\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\n      }\n\n      return ret;\n    } else {\n      // use chirp-z transform for non-power-of-2 FFT\n      return _czt(arr);\n    } // throw new Error('Can only calculate FFT of power-of-two size')\n\n  }\n});","map":{"version":3,"names":["arraySize","factory","name","dependencies","createFft","_ref","typed","matrix","addScalar","multiplyScalar","divideScalar","exp","tau","i","I","dotDivide","conj","pow","ceil","log2","Array","_ndFft","Matrix","create","toArray","arr","size","length","_fft","_1dFft","map","slice","dim","fill","_","_transpose","j","_czt","n","w","chirp","push","N2","xp","ichirp","fftXp","fftIchirp","fftProduct","ifftProduct","ret","_i","len","filter","k","p","q"],"sources":["C:/Users/lenovo/node_modules/mathjs/lib/esm/function/matrix/fft.js"],"sourcesContent":["import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'fft';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i', 'dotDivide', 'conj', 'pow', 'ceil', 'log2'];\nexport var createFft = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    divideScalar,\n    exp,\n    tau,\n    i: I,\n    dotDivide,\n    conj,\n    pow,\n    ceil,\n    log2\n  } = _ref;\n  /**\n   * Calculate N-dimensional fourier transform\n   *\n   * Syntax:\n   *\n   *     math.fft(arr)\n   *\n   * Examples:\n   *\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\n   *\n   *\n   * See Also:\n   *\n   *      ifft\n   *\n   * @param {Array | Matrix} arr    An array or matrix\n   * @return {Array | Matrix}       N-dimensional fourier transformation of the array\n   */\n  return typed(name, {\n    Array: _ndFft,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_ndFft(matrix.toArray()));\n    }\n  });\n\n  /**\n   * Perform an N-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _ndFft(arr) {\n    var size = arraySize(arr);\n    if (size.length === 1) return _fft(arr, size[0]);\n    // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\n    return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);\n  }\n\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @param {number} dim     dimension of the array to perform on\n   * @return {Array}         resulting array\n   */\n  function _1dFft(arr, dim) {\n    var size = arraySize(arr);\n    if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));\n    if (size.length === 1) return _fft(arr);\n    function _transpose(arr) {\n      // Swap first 2 dimensions\n      var size = arraySize(arr);\n      return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));\n    }\n    return _transpose(_1dFft(_transpose(arr), 1));\n  }\n  /**\n   * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _czt(arr) {\n    var n = arr.length;\n    var w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau)), n));\n    var chirp = [];\n    for (var i = 1 - n; i < n; i++) {\n      chirp.push(pow(w, divideScalar(pow(i, 2), 2)));\n    }\n    var N2 = pow(2, ceil(log2(n + n - 1)));\n    var xp = [...new Array(n).fill(0).map((_, i) => multiplyScalar(arr[i], chirp[n - 1 + i])), ...new Array(N2 - n).fill(0)];\n    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i) => divideScalar(1, chirp[i])), ...new Array(N2 - (n + n - 1)).fill(0)];\n    var fftXp = _fft(xp);\n    var fftIchirp = _fft(ichirp);\n    var fftProduct = new Array(N2).fill(0).map((_, i) => multiplyScalar(fftXp[i], fftIchirp[i]));\n    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);\n    var ret = [];\n    for (var _i = n - 1; _i < n + n - 1; _i++) {\n      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));\n    }\n    return ret;\n  }\n  /**\n   * Perform an 1-dimensional Fourier transform\n   *\n   * @param {Array} arr      The array\n   * @return {Array}         resulting array\n   */\n  function _fft(arr) {\n    var len = arr.length;\n    if (len === 1) return [arr[0]];\n    if (len % 2 === 0) {\n      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];\n      for (var k = 0; k < len / 2; k++) {\n        var p = ret[k];\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\n        ret[k] = addScalar(p, q);\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\n      }\n      return ret;\n    } else {\n      // use chirp-z transform for non-power-of-2 FFT\n      return _czt(arr);\n    }\n    // throw new Error('Can only calculate FFT of power-of-two size')\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}